11 октября 2021  
Лекция алгоритмы и структуры данных  
Автор конспекта: Костров Максим  


## B - дерево

- Каждая вершина содержит k(v) ключей x0 < x1 < ... < x_(v(k) - 1)  
Указатели на поддеревья (их будет k(v) + 1) a0, a1, a2 ... a_k(v)  
В a_0 все ключи меньше x0  
В a_k(v) ключи больше x_v(k) - 1  
В a_i все ключи больше x_(i - 1) и меньше x_(i)  
- Зафиксироавна констатна t >= 2 : 
	- В любой вершине v : k(v) <= 2 * t - 1
	- В любой некорневой вершине : k(v) >= t - 1
- Все пустые вершины находятся на одной и той-же глубине

Например, при t = 3, k(v) = [2 .. 5]
// TODO Picture

h - высота дерева  
n - количество влючей  
n >= 1 + 2(t - 1) + 2 (t - 1) * t + 2(t - 1) * t^2 + 2(t - 1) * t^3 + ... + 2(t - 1) * t^(h - 1)  
= 1 + 2(t - 1) * (t^h - 1) / (t - 1) = 2 * t^h - 1  
h <= log(t, (n + 1) / 2) (t - основание  

	struct Node {
		vector<T> keys;
		vector<NodeID> children;
	}

Мы пытаемся уменьшить количество обращений к памяти, поэтому жертвуем временем.  

#### search

	bool search(T key, NodeID root) {
		Node v = ReadFromDisk(root);
		while (true) {
			int ind = std::lower_bound(v.keys.begin(), v.keys.end(), key);
			if (ind != v.keys.end() && *ind == key) return true;
			NodeID child = v.children[ind - v.keys.begin()]
			if (!is_valid(child)) {
				// Это лист
				return false;
			}
			v = ReadFromDisk(child);
		}
	}

#### insert

Новая операция попилить вершину. Если в вершине v >= 2t - 1 вершин, то можно взять центральный и вывести его наверх. Вершина v разобьётся на две другие. А вершину пихнём вверх в нужное место в родителе. Если v - была корень, то создадим новую вершину из 1 элемента (так можно. Это специально оговорено для корневой вершины)

Итого `insert` - найдём как в `search` место куда нужно вставить. Вставим ключ key в лист в нужное место. И обратно когда идём делаем новую операцию если вершина переполнилась (в ней стало >= 2t - 1 ключей)

Другой алгоритм - один спуск - когда идём вниз уже пилим вершину, если можно. Тогда обратно идти не нужно т. к. итак всё будет ок. (Это лучший алгоритм)


#### erase

`erase` делается так. Сначала идём в вершину как в `search`, а потом удаляем.
Пусть мы хотим удалить ключ key

Рассмотрим случай когда key - лежит в листе дерева.

Инвариант: в вершине >= t вершин

Спускаемся вниз по дереву. Если в вершине >= t вершин - всё ок, идём дальше.  
Если в вершине t - 1 ключей, то посмотрим на одного брата. Если у него t - 1 ключей, то можем сделать обратную операцию попилу вершины. Из отца вершину вниз и смёржить v и её брата. Итого в новой вершине 2t - 1 вершина и всё ок.
А если у брата >= t ключей, то из брата ключ вверх, а из родителя вниз и поддеревья соответственно. Всё, в нашей вершине стало t вершин. Инвариант поддержан.  

Когда мы дойдём до листа, просто удалим его. 

А теперь как удалять элемент, если он не лист. Пусть мы нашли, что ключ key находится в вершине v - тогда найдём самого правого в левом поддереве. Или самого левого в самом правом поддереве. свапаем их и удаляем. (Или по-другому ) 

##### Массовые операции

+, = на отрезке - можно.

Можно делать. Нужно добавить split и merge

#### merge 

Есть два дерева и ключ между ними.  
Если деревья одинаковой высоты, то просто объединим [корень left, x, корень right]. Если теперь в корне больше чем 2t-1 элементов, то вынесем вверх средний элемент. 

Если высота разная - то пусть h1 > h2. Спускаемся вниз по правому дереву. доходим до уровня h2. И merge их. Если ключей стало >= 2t - тогда выпилим вверх и так рекурсивно. Или можно сразу идя вниз если ключей >= 2t - 1, то сразу пилим. Тогда не придётся идти вверх и не будет рекурсии.

`merge` за O(1 + |h1 - h2|)


#### split

Если ключ в x - корне, то разделим корень на два. Готово.
Иначе - рекурсивно будем делить поддерево на левое поддерево и правое. В конце у нас будет O(h) деревьев + вершин слева разных высот и O(h) деревьев справа + вершин разных высот. Вызовем от них merge и получим два слева и справа. 

### AVL - tree (split + merge)

#### merge

Дано два дерева l, r, и верина x. Нужно их слить.

Если |h1 - h2| <= 1, то просто подвесим их к x.

Иначе пойдём вправо вниз по первому дереву (h1 > h2) пока не придём в вершину v: h[v] = [h2, h2 + 1]. Merge(v, x, right). Подвесим к отцу v. B возможно сделаем поворот относительно отца v.

#### split

Делаем аналогично. Спускаемся вниз к ключу x. Откладываем это вверх - вниз.

Смёржим их снизу вверх. Готово.

Пусть у нас образовались вершины a1, a2, a3 ... и поддеревья al1, al2, al3 ...  
Утв. al1 = al2 - может быть. Но не может быть 3 подряд al1 == al2 == al3. Т. к. высоты в порядке.

По индукции доказываем, что на каждом уровне получим tree: h(tree) <= h(a1)

Т. к. h(a2) + 1 <= h1 

### Красно-чёрное дерево. (split & merge)

Там почти... (посмотри конспекты)

### Любое дерево (split & merge)

Много разных деревьев можно merge и split



