27 сентября 2021  
Лекция алгоритмы и структуры данных  
Филлипп Рухович  

## Двоичная куча d

Двоичная куча - двоичное дерево:

- Значание в вершине меньше значения (<=) в её потомке
- Глубина всех листьев отличается не больше чем на 1
- Последний слой заполняется последовательно (справа налево)

#### Свойства

N - количество вершин в двоичном дереве.

Удобная структура данных для двоичного дерева - массив A, где А[1] - корневой элемент.  
Потомки вершины с индексом i : A[i * 2] и A[i * 2 + 1]  
Тогда условия 2 и 3 из определения выполнены  
<Картинка>  

Высота кучи = высота двоичного дерева = O(logN)  

| Operations         | Операции            | Асимптотика
| ---------------    | ---------------     | --------
| Create             | Создать             | O(1)
| Decrease_key       | Уменьшить элемент   | O(logN)
| Insert             | Вставить            | O(logN)
| Find_min           | Найти минимум       | O(1)
| Extract_min        | Удалить минимум     | O(logN)
| Meld               | Объединение         | O(N)
| Erase              | Удалить элемент     | O(logN)

#### Восстановление свойств кучи

Если в куче изменяется один элемент, то она может перестать удовлетворять свойству упорядоченности. Для восстановления порядка служит функция Heapify.  
Она восстанавливает свойство упорядоченности в куче у которой правое и левое поддерево является корректной двоичной кучей.  
Допустим, что у i-го элемента левое и правое поддеревья корректны, тогда  
Если i-ый элемент меньше его сыновей, то куча уже корректная.  
Иначе поменяем i-ый элемент с наименьшим из его сыновей и рекурсивно выполним Heapify от этого сына. (Т. к. именно поддерево этого сына могло стать некорректным)

	Heapify(A, i)
		A[left] = 2 * i
		A[right] = 2 * i + 1
		largest = i
		if (A[left] < A[largest]) largest = left
		if (A[right] < A[largest]) largest = right
		if (largest != i)
			swap(A[i], A[largest])
			Heapify(A, largest)

#### Создание кучи

Можно создать пустую кучу за O(1)

Также можно создать кучу из неупорядоченного массива входных данных длиной N элементов  
Для этого положим элементы в массив A в любом порядке. Запустим функцию **`Heapify`** от всех вершин дерева в порядке их уменьшения глубины.  
Тогда все листья дерева уже являются корректными деревьями, а каждый следующий Heapify запускается от вершины с корректными поддеревьями.  
Таким образом, алгоритм сделает всю кучу корректной.  
Можно доказать, что этот алгоритм работает за время O(N), не O(logN).

#### Вставить элемент

Чтобы вставить новый элемент - положим его в первую незанятую ячейку массива. (В дереве он будет самым правым листом, если смотреть на самый глубокий ряд листьев) И давайте будем вызывать

#### Уменьшить элемент

Допустим, мы хотим заменить элемент i на новый, значение которого не больше предыдущего.
Т. к. элемент уменьшился, то он всё ещё меньше своих сыновей, то есть поддерево этого элемента является корректной кучей.  
  
Алгоритм такой: Если элемент больше отца, то условие 1 из определения соблюдено и ничего делать не нужно. Иначе, поменяем его с отцом и сделаем тоже самое рекурсивно для отца(в котором уже лежит наш начальный элемент).  

Образно говоря, мы проталкиваем наш элемент наверх пока он будет меньше отца. Когда он станет больше отца или станет корнем процесс завершится.

	Decrease_key(A, i, key)
		if (key > A[i])
			error // - новый ключ меньше предыдущего
		A[i] = key
		while (i > 0 && A[i / 2] > A[i])
			swap(A[i], A[i / 2])
			A[i] = (i / 2)

#### Найти минимум


#### Удалить минимум


#### Объединение двух куч


#### Удалить элемент



// TODO

Добавить весь код в style  
Добавить some style к функциям  


