4 октября 2021  
Лекция алгоритмы и структуры данных  

# Деревья поиска

![\sum_{i}{n - 1}{x_i^{2}}](https://latex.codecogs.com/svg.latex?%5Csum_%7B%5Cforall+i%7D%7Bx_i%5E%7B2%7D%7D)

## Двоичное дерево поиска

Двоичное дерево поиска - двоичное дерево  
- Ключ вершины больше всех ключей своего левого поддерева и меньше всех ключей правого поддерева
// TODO picture  
- В дереве не может быть двух элементов с одинаковым ключом  
- В вершине хранится ключ и две ссылки на правого и левого сыновей. (+ возможно на предка, если очень нужно)  
- Дерево хранится как указатель на корень. (+ возможно количество элементов)

Код вершины дерева	

	struct Node {
		int key;
		Node *left, *right;
	};

| Operations  | Асимптотика
| ----------  | -----------
| find        | O(h)
| insert      | O(h)
| erase       | O(h)
| successor   | O(h)
| predecessor | O(h)
| min         | O(h)
| max         | O(h)
| empty       | O(1)
| size        | O(1)

#### find


Функция `find` ищет вершину с ключом v в дереве. Эта функция проверяет наличие вершины v в дереве.  
Алгоритм такой: пойдём в корень дерева. Если корень = v, то мы нашли вершину, закончим алгоритм. Иначе если ключ корня < v, то наша вершина может лежать только в левом поддереве. Рекурсивно пойдём в левое поддерево и сделаем тоже самое. Аналогично, если ключ корня > v, то пойдём в правое поддерево. Если мы оказались в пустом поддереве (0 элементов), то такого ключа нет.  
То есть, мы рекурсивно спускаемся вниз по дереву и ищем нашу вершину  
	
#### insert
Функция `insert` вставляет элемент v, если его ещё нет в нашем дереве.  
1) Пытаемся найти вершину v как в `find`. В конце, если мы нашли вершину с ключом v, то ничего делать не нужно.  
Если её нет, то мы пришли к пустой вершине. Вставим на его место нашу новую вершину v.  

#### erase
Функция `erase` удаляет элемент v из дерева, если он в нём есть.  
1) Если v - лист, то просто удаляем вершину  
2) Если у v - один сын, то просто переподвесим сына вершины v к родителю вершины v  
3) Если у v - два сына, то пусть вершина a = самая левая вершина правого поддерева v. Меняем местами ключи (v и a). Тогда у вершины a всё ещё не более 1 сына и мы можем удалить её как в пункте 1 и 2.  

#### successor
`successor` - минимальный элемент больше v
Ищется он спуском по дереву вниз. Пусть ans = inf. Пусть сейчас мы ищем ответ в поддереве вершины a  
- Если a > v, то обновим ответ через a, т. к. ключ a подходит. Все элементы правого поддерева a больше v, а через v мы уже обновили ответ. Тогда пойдём рекурсивно в левое поддерево.
- Если a <= v, то просто пойдём в правое поддерево, т. к. никакие элементы из левого поддерева не подходят.

Код:
	
	void successor(a, v, &ans) {
		if (a > v) {
			ans = min(ans, a);
			successor(a.left, v, &ans);
		} else {
			successor(a.right, v, &ans);
		}
	}
	
#### predecessor
`predecessor` - максимальный элемент меньше v - ищется аналогично `successor`

	
#### min / max
Минимальный / максимальный элемент - самый правый и самый левый элемент дерева.  
Нужно спускаться всегда влево (вправо) от корня, чтобы найти минимальный (максимальный) элемент  

#### empty
Функция `empty` говорит, пустое ли сейчас дерево.  
Можно проверять, что корень - пустая вершина  
Или что количество элементов = 0  

#### size
Функция `size` даёт количество элементов в дереве.  
Нужно поддерживать переменную, в которой хранить количество элементов в дереве.  
Увеличивать её на 1 при успешном `insert` и уменьшать на 1 при успешном `erase`.  

### Количество двоичных деревьев поиска
Сколько существует различных неизоморфных двоичных деревьев поиска из n вершин?  
Ответ: n - 1 (-ое) [Число Каталана](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%B0%D0%BD%D0%B0)  
Или можно посчитать ответ динамикой: dp\[i\] - сколько различных деревьев существует из i вершин. Тогда переберём количество вершин слева от корня и получим dp\[v\] = $\sum_1^n$
Также различных неизоморфных двоичных деревьев поиска из n вершин столько же, сколько и правильных скобочных последовательностей длины 2 * n  
Есть красивый рисунок биекции из двоичного дерева в ПСП  
// TODO picture
	
## Красно-чёрное дерево

	
	struct Node {
		int key;
		Node *left, *right;
		bool color;  // red or black
	};

	
#### Инвариант дерева
- x (пустая вершина) - чёрная вершина
- корень - чёрный
- У красной вершины оба ребёнка чёрные
- У чёрной вершины дети любого цвета
- количество чёрных вершин на пути от корня (включительно) до x (включительно) не зависит от выбора x.

#### Свойства
- Чёрная высота - максимальное количество чёрных вершин на пути от любого x до вершины
- Глубина дерева не более 2logN (т. к. нет двух красных подряд)  
- У каждой чёрной вершины высоты h есть хотя бы два поддерева высоты h - 1. Может быть 4 поддерева высоты h - 1. <picture>
- Все операции кроме insert и erase - делаем также, как и в двоичном дереве поиска.

### Insert
Дерево изначально корректное.  
Найдём куда вставлять вершину x.  
- Если родитель чёрный - просто вставим наш элемент как красный
- Иначе (родитель - красный)

Новый инвариант : Дерево с проблемой - дерево с одной красной вершиной у которой отец тоже красный

Его решение (приведение к корректному инварианту):
- Если наша

### Erase

Новый инвариант: есть поддерево x такое, что у всех его листьев (x - пустых) глубина на 1 меньше, чем нужно.  
Если у x нет родителя - всё ок  
Иначе  


## Декартово дерево (Cartesian tree) (Дуча)

Приоритеты  y1   y2   y3   ...   yn  
Ключи       x1 < x2 < x3 < ... < xn  

- Для каждой вершины : y(приоритет) в детях больше, чем y(приоритет) в вершине
- Можно нарисовать на плоскости
- Если приоритеты различны, то можно однозначно построить декартово дерево
- Если приоритеты - случайное число, то высота дерева = O(logN)

Операции `split` и `merge`

#### split

Функция split должна разделить дерево на два других дерева, таких что у первого все ключи <= x, а у второго все ключи > x  

Алгоритм:  
	Пусть корень дерева = i  
	Если ( x[i] <= x ) разделим
	Иначе ( x[i] > x )


	split(A, x)
		pass


#### merge

Пусть даны два дерева таких, что все x первого дерева < всех x второго дерева
Функция merge сливает два таких дерева в одно корректное декартово дерево

Алгоритм:
Пусть приоритет правого дерева больше, тогда ...
Иначе приоритет второго дерева больше, тогда ...

	merge(A, B)
		pass

#### insert

Сделаем `split` по ключу x и дальше `merge` трёх деревьев (центральное - просто вершина x, которую мы вставляем)

insert(A, x)
B, C = split(A, B)

#### Свойства

Можно делать много крутых вещей
- Reverse на подотрезке
- Циклический сдвиг
- К-ая порядковая статистика

### Декартово дерево по неявному ключу

Приоритеты  y1   y2   y3   ...   yn  
Ключи       x1   x2   x3   ...   xn (Теперь не <)  

- Для каждой вершины : y(приоритет) в детях больше, чем y(приоритет) в вершине

Операции `split` и `merge` - также

Мы можем работать с ними как с последовательностью элементов
Можно разрезать где угодно и склеить любые части
Можно менять изначальный порядок x-ов

### ???

Дан массив и нужно отвечать на запросы  
RSQ - range sum query - сумма на отрезке  
MRQ - range min query - минимум на отрезке  

static RSQ - когда массив статичный и не меняется  
Решение: префиксные суммы get(l, r) = dp[r] - dp[l - 1]

Идемпотентность операции = f(x, x) = x

### Sparse table

Учимся делать static MRQ - минимум на отрезке на статичном массиве  

st[i][l] = min(a[i], a[i + 1], a[i + 2], ... a[i + 2^l - 1])

get(l, r) = ?  
пусть k - max степень двойки: r - l + 1 >= 2^k  
Тогда ans = min(st[l][k], st[r - 2^k + 1][k]);  
<Рисуночек>

## Дерево отрезков снизу

Работаем

st = min{ 2^k | 2^k >= n } - максимальная степень двойки <= n  

	void update(int pos, int x) {
		pos += st - 1;
		tree[pos] = x;
		for (pos /= 2; pos; pos /= 2)
			tree[pos] = tree[pos * 2] + tree[pos * 2 + 1];
	}

	// Мы просто идем по уровням снизу вверх и если крайние элементы нужно брать, то берём их и сдвигаем границы
	int get_sum(int l, int r) {
		l += st - 1;
		r += st - 1;
		int ans = 0;
		while (l <= r) {
			if (l & 1)
				ans += tree[l++];
			if (!(r & 1))
				ans += tree[r--];
			l /= 2;
			r /= 2;
		}
		return sum;
	}

Можно также искать перемножение матриц на отрезке, но нужно будет хранить текущий ответ справа и слева и потом их тоже перемножить.  

### Массовые операции

*Реализация дерева отрезков сверху*

	// v - index
	// tl - tree left index
	// tr - tree right index
	// ql - query left index
	// qr - query right index
	int get_sum(v, tl, tr, ql, qr) {
		if (tr <= ql || qr <= tl) return 0;  // if [tl, tr] and [ql, qr] not intersect
		if (ql <= tl && tr <= qr) return tree[v];
		push(v, tl, tr);  // если не знаете, что это пока проигнорьте, потом вернётесь
		mid = (tl + tr) / 2;
		return get_sum(v * 2, tl, mid, ql, qr)
			 + get_sum(v * 2 + 1, mid, tr, ql, qr);
	}


#### Операция присвоение на отрезке

Вкратце - Нужно Дерево Отрезков сверху и сделать отложенные операции `push`  

- Новая операция присвоение на отрезке  
- Свойство такой структуры - чтобы добраться до вершины v нужно пройти сначала его отца.

Заведём доп. значение для каждой вершины d[i]  
Если d[i] = -1, то он ничего не значит  
Иначе все элементы на данном отрезке вершины v равны d[i], но дети ещё этого не знают (соответственно сумма = d[i] * len(длину отрезка или количество элементов на отрезке))  
И когда мы заходим в вершину v мы вызываем push который передаёт push в сыновей и делает свой d[v] = -1  

	void push(v, tl, tr)
		pass

### Возвращаемся в декартово дерево

Теперь мы умеем делать в декартовом дереве всё тоже, что и в дереве отрезков  

#### Разворот на отрезке  

booled is_reversed;  // флаг который отвечает за то, развёрнут ли данный отрезок (передаётся сыне и второму)  

Алгоритм Разворота на отрезке  
- split нужный отрезок  
- is_reversed[v] ^= 1;  
- swap( left_son, right_son )  
- merge обратно  

Push  
- Если is_reversed, то пропушим его в сыновей и сделаем для них  
is_reversed[l] ^= 1;  
is_reversed[r] ^= 1;  
is_reversed[v] = 0;  

### Splay tree (Сплей дерево)

Splay tree - любое двоичное дерево

#### splay

Операция `splay(v)` - меняет дерево так, чтобы вершина v стала корнем. Использует zig и zigzig zigzag

Можно не хранить родителей - при спуске вниз запишем всех в стек

##### zig

// TODO picture

##### zigzig
	
// TODO picture

##### zigzag

// TODO picture  

	void splay(v) {
		while (v != root) {

		}
	}

#### find

Найдём вершину и вызовем splay от неё или последнего места, где мы остановились

#### потенциалы

- split
- merge
- find
- insert
- erase

sz[v] = размер поддерева sz  
r[v] = log(2, sz[v])  
Ф(root) = сумма по всем вершинам по r[v]  - потенциал всего дерева  
Потенциал вершины = r[v]  



**Splay**  
Учётная стоимость = logN
Учётная стоимость `splay(v)` <= `3 * (r[root] - r[v]) + 1` <= `O(log( sz[root] / sq[v] + 1))`  

Считаем её
r[v] - до шага
r'[v] - после шага

Считаем учётную стоимость операций:

- zig:  
	1 + F'(root) - F(root) = 1 + r'[v] + r'[a] - r[v] - r[a] = 1 + r'[a] - r[v]  (т. к. r'[v] = r[a])  
	1 + r'[a] - r[v] <= 1 + r'[v] - r[v] <= 1 + 3(r'[v] - r[v])

- zigzig:  
	2 + F'[v] - F[v] = 2 + r'[x] + r'[p] + r'[q] - r[x] - r[p] - r[q] = 2 + r'[p] + r'[q] - r[x] - r[p] = 
	(r'[x] = r[q])
	= 2 + log(2, 2 + )

	// TODO picture
- 

**Find**  
учётная стоимость = splay(v)

**Insert**  
учётная стоимость = splay(v)

**Erase**  
учётная стоимость = splay(v)

**split**  
Сделаем `find` от того же x и потом левое поддерево + вершина = левый ответ, а правое поддерево = правый ответ

учётная стоимость = splay(v)

**merge**  
вызовем splay от самого правой вершины левого дерева  
И потом правый сын первого дерева = второе дерево  

учётная стоимость = splay(v)


#### Другое

Введём вместо sz[v] - w[v]  
sum_w[v] - положительное число = сумма по всем w[e], где e - вершина поддерева  
r[v] = log(2, sum_w[v])  

Пусть мы c[i] раз вызываемся от вершины i
Тогда мы можем перераспределить веса w[i] - больше у тех, кто вызывается больше

время работы = log (c) / /.... . /???????

Итоговое время работы:  
O(m + sum(i = [1 .. n], c[i] * log(2, c / c[i])))  

